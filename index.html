<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AI æ‰‹å‹¢æ§åˆ¶ç«‹æ–¹é«”</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #v-preview { position: fixed; bottom: 15px; right: 15px; width: 140px; transform: scaleX(-1); border: 2px solid #fff; border-radius: 8px; z-index: 10; }
        #overlay { position: fixed; top: 15px; left: 15px; color: #fff; background: rgba(0,0,0,0.6); padding: 12px; border-radius: 8px; z-index: 10; pointer-events: none; }
    </style>
</head>
<body>

<div id="overlay">
    <div id="msg">ğŸš€ æ­£åœ¨åˆå§‹åŒ– 3D ç©ºé–“...</div>
    <small>ğŸ–ï¸ æ®æ‰‹æ—‹è½‰ | ğŸ¤ æåˆç¸®æ”¾ | ğŸ–±ï¸ æ»‘é¼ ä¹Ÿå¯æ§åˆ¶</small>
</div>
<video id="v-preview"></video>

<script>
    const msg = document.getElementById('msg');
    const videoElement = document.getElementById('v-preview');

    // --- 1. Three.js åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

// --- 2. å»ºç«‹æ–‡å­—è²¼åœ–å‡½å¼ ---
    function createTextMaterial(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512; // è§£æåº¦é«˜ä¸€é»å­—æ‰æ¸…æ™°
        canvas.height = 512;

        // èƒŒæ™¯
        ctx.fillStyle = '#0f172a'; 
        ctx.fillRect(0, 0, 512, 512);

        // å¤–æ¡†
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 20;
        ctx.strokeRect(0, 0, 512, 512);

        // æ–‡å­—
        ctx.font = 'Bold 120px Arial';
        ctx.fillStyle = '#38bdf8';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // åŠ ä¸Šä¸€é»ç™¼å…‰æ•ˆæœ
        ctx.shadowColor = '#38bdf8';
        ctx.shadowBlur = 30;
        ctx.fillText(text, 256, 256);

        const texture = new THREE.CanvasTexture(canvas);
        return new THREE.MeshBasicMaterial({ map: texture });
    }

    // å°‡å…­å€‹é¢è²¼ä¸Šä¸åŒçš„å­—
    const materials = [
        createTextMaterial('I'),    // å³
        createTextMaterial('LOVE'), // å·¦
        createTextMaterial('Jia'),  // ä¸Š
        createTextMaterial('I'),    // ä¸‹
        createTextMaterial('LOVE'), // å‰
        createTextMaterial('Jia')   // å¾Œ
    ];

    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), materials);
    scene.add(cube);
    camera.position.z = 5;

    // --- 3. æ‰‹å‹¢åµæ¸¬é‚è¼¯ ---
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });

    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            msg.innerText = "âœ… AI é€£ç·šæˆåŠŸï¼šæ‰‹å‹¢æ§åˆ¶ä¸­";
            isMouseActive = false; // å„ªå…ˆä½¿ç”¨æ‰‹å‹¢
            const h = results.multiHandLandmarks[0];
            
            // æ—‹è½‰æ˜ å°„
            targetY = (h[9].x - 0.5) * -6;
            targetX = (h[9].y - 0.5) * 4;
            
            // ç¸®æ”¾æ˜ å°„ (é£ŸæŒ‡ 8 èˆ‡å¤§æ‹‡æŒ‡ 4)
            const d = Math.hypot(h[8].x - h[4].x, h[8].y - h[4].y);
            targetZ = 8 - (d * 15);
        } else {
            msg.innerText = "ğŸ‘‹ æœªåµæ¸¬åˆ°æ‰‹ (æ»‘é¼ æ¸¬è©¦æ¨¡å¼)";
        }
    });

    // --- 4. å‚™æ´æ»‘é¼ æ§åˆ¶ ---
    window.addEventListener('mousemove', (e) => {
        if (msg.innerText.includes("æœªåµæ¸¬åˆ°æ‰‹")) {
            targetY = (e.clientX / window.innerWidth - 0.5) * 6;
            targetX = (e.clientY / window.innerHeight - 0.5) * 4;
        }
    });

    // --- 5. æ¸²æŸ“èˆ‡ç›¸æ©Ÿå•Ÿå‹• ---
    function animate() {
        // å¹³æ»‘æ…£æ€§é‹å‹•
        cube.rotation.y += (targetY - cube.rotation.y) * 0.1;
        cube.rotation.x += (targetX - cube.rotation.x) * 0.1;
        camera.position.z += (targetZ - camera.position.z) * 0.1;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
    animate();

    const cameraHelper = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraHelper.start();
</script>
</body>
</html>


